<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vZEV Abrechnung für Nachbarn</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type="file"]::file-selector-button {
            @apply bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg cursor-pointer transition-colors duration-300 hover:bg-indigo-700;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-lg p-6 md:p-8">
        
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">vZEV Abrechnung für Nachbarn</h1>
            <p class="text-gray-500 mt-2">Laden Sie die Lastgangdaten aller Teilnehmer hoch.</p>
        </div>

        <!-- Price Inputs Section -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6 bg-gray-50 p-4 rounded-lg border">
            <div>
                <label for="price-buy" class="block text-sm font-medium text-gray-700">Netzbezug (CHF/kWh)</label>
                <input type="number" id="price-buy" value="0.25" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
            </div>
            <div>
                <label for="price-sell" class="block text-sm font-medium text-gray-700">Einspeisung (CHF/kWh)</label>
                <input type="number" id="price-sell" value="0.10" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
            </div>
            <div>
                <label for="price-neighbor" class="block text-sm font-medium text-gray-700">Nachbarn (CHF/kWh)</label>
                <input type="number" id="price-neighbor" value="0.18" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
            </div>
        </div>

        <!-- Participant Configuration -->
        <div class="mb-6 bg-gray-50 p-4 rounded-lg border">
            <h3 class="text-lg font-semibold text-gray-700 mb-4">Teilnehmer konfigurieren</h3>
            <div id="participants-config" class="space-y-4">
                <!-- Participants will be added here dynamically -->
            </div>
            <button id="add-participant-btn" class="mt-4 bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors duration-300">
                + Teilnehmer hinzufügen
            </button>
        </div>

        <div class="mb-6">
            <label for="file-upload" class="block text-sm font-medium text-gray-700 mb-2">CSV-Dateien auswählen:</label>
            <input id="file-upload" type="file" multiple accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:border-0 file:rounded-lg">
        </div>

        <div class="text-center mb-8">
            <button id="process-btn" class="w-full md:w-auto bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105 duration-300">
                Abrechnung berechnen
            </button>
        </div>

        <div id="results-container" class="space-y-6 hidden">
            <!-- Results will be dynamically added here for each participant -->
        </div>

    </div>

    <script>
        // --- DOM Element References ---
        const fileUpload = document.getElementById('file-upload');
        const processBtn = document.getElementById('process-btn');
        const priceBuyInput = document.getElementById('price-buy');
        const priceSellInput = document.getElementById('price-sell');
        const priceNeighborInput = document.getElementById('price-neighbor');
        const resultsContainer = document.getElementById('results-container');
        const participantsConfig = document.getElementById('participants-config');
        const addParticipantBtn = document.getElementById('add-participant-btn');

        // --- Constants for Data Processing ---
        const CONSUMPTION_CODE = '1-1:1.29.0*255'; // Netzbezug
        const PRODUCTION_CODE = '1-1:2.29.0*255'; // Netzeinspeisung (Überschuss)
        
        // --- Dynamic Participants List ---
        let participants = [];
        let participantIdCounter = 0;
        
        // Initialize with default participants
        function initializeDefaultParticipants() {
            addParticipant('Produzent 1', 'CH1035501234500000000000000000859', true, true);
            addParticipant('Produzent 2', 'CH1035501234500000000000000005020', true, true);
            addParticipant('Konsument 1', '', false, true);
            addParticipant('Konsument 2', '', false, true);
        }
        
        function addParticipant(name = '', meterId = '', isProducer = false, isConsumer = true) {
            const id = participantIdCounter++;
            participants.push({
                id,
                name: name || `Teilnehmer ${id + 1}`,
                meterId: meterId || '',
                isProducer,
                isConsumer
            });
            renderParticipantConfig();
        }
        
        function removeParticipant(id) {
            participants = participants.filter(p => p.id !== id);
            renderParticipantConfig();
        }
        
        function updateParticipant(id, field, value) {
            const participant = participants.find(p => p.id === id);
            if (participant) {
                if (field === 'isProducer' || field === 'isConsumer') {
                    participant[field] = value === 'true' || value === true;
                } else {
                    participant[field] = value;
                }
            }
        }
        
        function renderParticipantConfig() {
            participantsConfig.innerHTML = participants.map(p => `
                <div class="border rounded-lg p-3 bg-white" data-participant-id="${p.id}">
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-2 items-center">
                        <input type="text" 
                            value="${p.name}" 
                            onchange="updateParticipant(${p.id}, 'name', this.value)"
                            placeholder="Name"
                            class="px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <input type="text" 
                            value="${p.meterId}" 
                            onchange="updateParticipant(${p.id}, 'meterId', this.value)"
                            placeholder="Zähler-ID"
                            class="px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <div class="flex gap-4">
                            <label class="flex items-center">
                                <input type="checkbox" 
                                    ${p.isProducer ? 'checked' : ''}
                                    onchange="updateParticipant(${p.id}, 'isProducer', this.checked)"
                                    class="mr-2">
                                <span class="text-sm">Produzent</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" 
                                    ${p.isConsumer ? 'checked' : ''}
                                    onchange="updateParticipant(${p.id}, 'isConsumer', this.checked)"
                                    class="mr-2">
                                <span class="text-sm">Konsument</span>
                            </label>
                        </div>
                        <button onclick="removeParticipant(${p.id})" 
                            class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 transition-colors">
                            Entfernen
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        addParticipantBtn.addEventListener('click', () => addParticipant());
        
        // Initialize with default participants
        initializeDefaultParticipants();

        processBtn.addEventListener('click', async () => {
            if (fileUpload.files.length === 0) {
                displayMessage('Bitte wählen Sie die CSV-Dateien aus.');
                return;
            }

            resultsContainer.classList.remove('hidden');
            resultsContainer.innerHTML = '<p class="text-center text-gray-400">Dateien werden verarbeitet...</p>';
            
            try {
                const fileContents = await Promise.all(Array.from(fileUpload.files).map(f => f.text()));
                const timeSeriesData = structureDataByTime(fileContents);
                const results = calculateVZEV(timeSeriesData);
                const prices = {
                    buy: parseFloat(priceBuyInput.value) || 0,
                    sell: parseFloat(priceSellInput.value) || 0,
                    neighbor: parseFloat(priceNeighborInput.value) || 0,
                };
                displayResults(results, prices);

            } catch (error) {
                console.error('Fehler bei der Verarbeitung:', error);
                displayMessage('Ein Fehler ist aufgetreten. Details in der Konsole.');
            }
        });

        function structureDataByTime(fileContents) {
            const dataMap = new Map();
            fileContents.forEach(content => {
                const lines = content.split('\n').filter(line => line.trim());
                lines.forEach(line => {
                    const delimiter = line.includes(';') ? ';' : ',';
                    const cols = line.split(delimiter);
                    if (cols.length < 5) return;

                    const meterId = cols[0];
                    const typeCode = cols[1];
                    const date = cols[3];
                    const values = cols.slice(4).map(v => parseFloat(v) || 0);

                    if (!dataMap.has(date)) {
                        const dayData = {
                            producers: {},
                            consumers: {}
                        };
                        
                        // Initialize data structure for each participant
                        participants.forEach(p => {
                            if (p.isProducer) {
                                dayData.producers[p.meterId] = {
                                    feedIn: Array(96).fill(0),
                                    import: Array(96).fill(0)
                                };
                            }
                            if (p.isConsumer) {
                                if (!dayData.consumers[p.meterId]) {
                                    dayData.consumers[p.meterId] = {
                                        import: Array(96).fill(0)
                                    };
                                }
                            }
                        });
                        
                        dataMap.set(date, dayData);
                    }
                    
                    const dayData = dataMap.get(date);
                    const participant = participants.find(p => p.meterId === meterId);
                    
                    if (participant) {
                        if (participant.isProducer && typeCode === PRODUCTION_CODE) {
                            if (dayData.producers[meterId]) {
                                dayData.producers[meterId].feedIn = values;
                            }
                        } else if (typeCode === CONSUMPTION_CODE) {
                            if (participant.isProducer && dayData.producers[meterId]) {
                                dayData.producers[meterId].import = values;
                            } else if (participant.isConsumer && dayData.consumers[meterId]) {
                                dayData.consumers[meterId].import = values;
                            }
                        }
                    }
                });
            });
            return dataMap;
        }

        function calculateVZEV(timeSeriesData) {
            // Initialize results structure for each participant
            const participantResults = {};
            participants.forEach(p => {
                participantResults[p.id] = {
                    name: p.name,
                    meterId: p.meterId,
                    isProducer: p.isProducer,
                    isConsumer: p.isConsumer,
                    totalProduction: 0,
                    totalConsumption: 0,
                    soldToOthers: 0,
                    boughtFromOthers: 0,
                    gridFeedIn: 0,
                    gridImport: 0,
                    transactions: [] // Detailed transactions for transparency
                };
            });

            // Process each time interval
            for (const dayData of timeSeriesData.values()) {
                for (let i = 0; i < 96; i++) {
                    // Calculate total available production at this interval
                    let totalAvailableProduction = 0;
                    const producerSurplus = {};
                    
                    // Calculate surplus for each producer
                    participants.filter(p => p.isProducer).forEach(producer => {
                        if (dayData.producers[producer.meterId]) {
                            const production = dayData.producers[producer.meterId].feedIn[i] || 0;
                            const ownConsumption = dayData.producers[producer.meterId].import[i] || 0;
                            
                            participantResults[producer.id].totalProduction += production;
                            participantResults[producer.id].totalConsumption += ownConsumption;
                            
                            // Producer's surplus is their production
                            // Their own consumption is handled separately from grid import
                            producerSurplus[producer.id] = production;
                            totalAvailableProduction += production;
                        }
                    });
                    
                    // Calculate total demand from all consumers (including producers as consumers)
                    let totalDemand = 0;
                    const consumerDemand = {};
                    
                    participants.filter(p => p.isConsumer).forEach(consumer => {
                        let demand = 0;
                        
                        if (consumer.isProducer && dayData.producers[consumer.meterId]) {
                            // Producer-consumer: their demand is their grid import
                            demand = dayData.producers[consumer.meterId].import[i] || 0;
                        } else if (dayData.consumers[consumer.meterId]) {
                            // Pure consumer: their demand is their total import
                            demand = dayData.consumers[consumer.meterId].import[i] || 0;
                        }
                        
                        consumerDemand[consumer.id] = demand;
                        totalDemand += demand;
                        
                        if (!consumer.isProducer) {
                            participantResults[consumer.id].totalConsumption += demand;
                        }
                    });
                    
                    // Distribute available production to consumers proportionally
                    if (totalAvailableProduction > 0 && totalDemand > 0) {
                        const totalDistributed = Math.min(totalAvailableProduction, totalDemand);
                        
                        // Distribute to consumers based on their demand ratio
                        participants.filter(p => p.isConsumer).forEach(consumer => {
                            if (consumerDemand[consumer.id] > 0) {
                                const consumerShare = (consumerDemand[consumer.id] / totalDemand) * totalDistributed;
                                participantResults[consumer.id].boughtFromOthers += consumerShare;
                                participantResults[consumer.id].gridImport += consumerDemand[consumer.id] - consumerShare;
                                
                                // Distribute this consumption across producers proportionally
                                participants.filter(p => p.isProducer).forEach(producer => {
                                    if (producerSurplus[producer.id] > 0) {
                                        const producerContribution = (producerSurplus[producer.id] / totalAvailableProduction) * consumerShare;
                                        participantResults[producer.id].soldToOthers += producerContribution;
                                    }
                                });
                            }
                        });
                        
                        // Calculate grid feed-in (surplus not consumed locally)
                        const totalSurplusConsumed = totalDistributed;
                        participants.filter(p => p.isProducer).forEach(producer => {
                            if (producerSurplus[producer.id] > 0) {
                                const producerSoldLocally = (producerSurplus[producer.id] / totalAvailableProduction) * totalSurplusConsumed;
                                participantResults[producer.id].gridFeedIn += producerSurplus[producer.id] - producerSoldLocally;
                            }
                        });
                    } else if (totalAvailableProduction > 0) {
                        // No demand, all production goes to grid
                        participants.filter(p => p.isProducer).forEach(producer => {
                            participantResults[producer.id].gridFeedIn += producerSurplus[producer.id] || 0;
                        });
                    } else if (totalDemand > 0) {
                        // No production, all demand from grid
                        participants.filter(p => p.isConsumer).forEach(consumer => {
                            participantResults[consumer.id].gridImport += consumerDemand[consumer.id] || 0;
                        });
                    }
                }
            }
            
            return participantResults;
        }

        function displayResults(results, prices) {
            const formatKwh = (num) => num.toFixed(3).replace('.', ',');
            const formatChf = (num) => num.toFixed(2).replace('.', ',');
            
            resultsContainer.innerHTML = '';
            
            // Display results for each participant
            Object.values(results).forEach((participant, index) => {
                const isProducer = participant.isProducer;
                const bgColor = isProducer ? 'bg-green-800' : 'bg-blue-900';
                
                // Calculate financial results
                const incomeFromNeighbors = participant.soldToOthers * prices.neighbor;
                const incomeFromGrid = participant.gridFeedIn * prices.sell;
                const costFromNeighbors = participant.boughtFromOthers * prices.neighbor;
                const costFromGrid = participant.gridImport * prices.buy;
                const totalIncome = incomeFromNeighbors + incomeFromGrid;
                const totalCost = costFromNeighbors + costFromGrid;
                const netResult = totalIncome - totalCost;
                
                const participantHtml = `
                    <div class="${bgColor} bg-opacity-90 text-white rounded-xl p-6 shadow-inner">
                        <h2 class="text-2xl font-bold text-center mb-6">
                            ${participant.name} 
                            ${participant.meterId ? `(Zähler ...${participant.meterId.slice(-4)})` : ''}
                        </h2>
                        <div class="space-y-4">
                            ${isProducer ? `
                                ${createResultRow('Gesamtproduktion', `${formatKwh(participant.totalProduction)} kWh`)}
                                ${participant.isConsumer ? createResultRow('Eigenverbrauch', `${formatKwh(participant.totalConsumption)} kWh`) : ''}
                                <hr class="border-gray-600 my-3">
                                ${createResultRow('An Nachbarn verkauft', `${formatKwh(participant.soldToOthers)} kWh`, `Ertrag: ${formatChf(incomeFromNeighbors)} CHF`)}
                                ${createResultRow('Ins Netz eingespeist', `${formatKwh(participant.gridFeedIn)} kWh`, `Ertrag: ${formatChf(incomeFromGrid)} CHF`)}
                            ` : ''}
                            
                            ${participant.isConsumer ? `
                                ${!isProducer ? createResultRow('Gesamtverbrauch', `${formatKwh(participant.totalConsumption)} kWh`) : ''}
                                <hr class="border-gray-600 my-3">
                                ${createResultRow('Von Nachbarn bezogen', `${formatKwh(participant.boughtFromOthers)} kWh`, `Kosten: ${formatChf(costFromNeighbors)} CHF`)}
                                ${createResultRow('Vom Netz bezogen', `${formatKwh(participant.gridImport)} kWh`, `Kosten: ${formatChf(costFromGrid)} CHF`)}
                            ` : ''}
                            
                            <hr class="border-gray-600 my-3">
                            <div class="flex justify-between items-center py-2">
                                <span class="font-semibold">Gesamtertrag</span>
                                <span class="font-semibold">${formatChf(totalIncome)} CHF</span>
                            </div>
                            <div class="flex justify-between items-center py-2">
                                <span class="font-semibold">Gesamtkosten</span>
                                <span class="font-semibold">${formatChf(totalCost)} CHF</span>
                            </div>
                            <hr class="border-gray-600 my-3">
                            <div class="flex justify-between items-center py-2 text-lg">
                                <span class="font-bold ${netResult >= 0 ? 'text-green-400' : 'text-red-400'}">Nettoergebnis</span>
                                <span class="font-bold ${netResult >= 0 ? 'text-green-400' : 'text-red-400'}">${formatChf(netResult)} CHF</span>
                            </div>
                        </div>
                    </div>
                `;
                
                resultsContainer.innerHTML += participantHtml;
            });
        }

        function createResultRow(label, value, monetaryValue = '') {
            return `
                <div class="flex justify-between items-center py-2 border-b border-gray-700">
                    <div>
                        <span class="text-gray-300">${label}</span>
                        ${monetaryValue ? `<br><span class="text-sm text-indigo-300">${monetaryValue}</span>` : ''}
                    </div>
                    <span class="font-semibold text-lg text-white text-right">${value}</span>
                </div>
            `;
        }

        function displayMessage(message) {
            resultsContainer.classList.remove('hidden');
            resultsContainer.innerHTML = `<p class="text-center text-red-400">${message}</p>`;
        }
    </script>
</body>
</html>
